// Copyright 2023 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto2";

option optimize_for = LITE_RUNTIME;
option java_package = "org.chromium.components.optimization_guide.proto";
option java_outer_classname = "VisualSearchModelMetadataProto";

package optimization_guide.proto;

message FeatureLibrary {
  enum ImageLevelFeatureName {
    IMAGE_LEVEL_UNSPECIFIED = 0;

    // Features of the original image.
    IMAGE_ORIGINAL_AREA = 1;
    IMAGE_ORIGINAL_ASPECT_RATIO = 2;
    IMAGE_ORIGINAL_HEIGHT = 11;
    IMAGE_ORIGINAL_WIDTH = 12;

    // Features of the image as scaled on the page. Not all of the area may
    // be visible.
    IMAGE_ONPAGE_AREA = 3;
    IMAGE_ONPAGE_HEIGHT = 9;
    IMAGE_ONPAGE_WIDTH = 10;
    IMAGE_ONPAGE_ASPECT_RATIO = 4;

    // The actually visible area of the image on the page.
    IMAGE_VISIBLE_AREA = 5;

    // Fraction of image that is in viewport. Computed as
    // IMAGE_VISIBLE_AREA / IMAGE_ONPAGE_AREA.
    IMAGE_FRACTION_VISIBLE = 6;

    // Scores of the shopping and sens classifiers.
    SHOPPING_CLASSIFIER_SCORE = 7;
    SENS_CLASSIFIER_SCORE = 8;
  }

  // Enum listing the ways in which we can normalize a feature.
  enum NormalizingOp {
    NORMALIZE_UNSPECIFIED = 0;
    // Normalize by the size of the viewport area.
    BY_VIEWPORT_AREA = 1;
    // Normalize by the max value of the feature.
    BY_MAX_VALUE = 2;
  }

  // Enum listing the types of thresholding operators.
  enum ThresholdingOp {
    THRESHOLDING_UNSPECIFIED = 0;
    // Greater than.
    GT = 1;
    // Less than.
    LT = 2;
  }
}

// A rule that applies a threshold on a feature. The rule is satisfied if the
// value of the feature with /feature_type/ passes the /threshold/ according to
// the given /op/. Eg. suppose feature_type = IMAGE_ORIGINAL_AREA, op = GT, and
// threshold = 5. Then the rule is satisfied if the original area of the image
// is greater than 5.
message ThresholdingRule {
  optional FeatureLibrary.ImageLevelFeatureName feature_name = 1;
  // The normalizing_op is not required.
  optional FeatureLibrary.NormalizingOp normalizing_op = 2;
  optional FeatureLibrary.ThresholdingOp thresholding_op = 3;
  optional float threshold = 4;
}

// An OR-of-thresholding-rules is satisfied if any of the thresholding rules it
// contains are satisfied.
message OrOfThresholdingRules {
  repeated ThresholdingRule rules = 1;
}

// Overall spec for the whole module.
message EligibilitySpec {
  // List of light-weight thresholding rules that we use in the first-cut run to
  // cheaply prune ineligible images. All of the eligibility rules must be
  // satisfied for an image to be considered eligible.
  repeated OrOfThresholdingRules cheap_pruning_rules = 1;
  // These are thresholding rules that depend on more expensive-to-compute
  // inputs such as the sensitivity and intent classifications.
  repeated OrOfThresholdingRules classifier_score_rules = 2;
  // Before running these rules, normalizing features are recomputed only over
  // the images that remain after the second pass.
  repeated OrOfThresholdingRules post_renormalization_rules = 3;
}

// The message contains a set of params to config visual search classification.
message VisualSearchModelMetadata {
  optional EligibilitySpec eligibility_spec = 1;
}
